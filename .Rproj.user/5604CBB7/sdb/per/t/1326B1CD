{
    "contents" : "# October - November 2015; updated January 2016\n# This script was written for Johns Hopkins University Coursera \"Capstone\" course \n\n#--------------------------\nlibrary(jsonlite)\n\n# download data from:  http://www.yelp.com/dataset_challenge\n# data assumed to be in directory 'yelp_dataset_challenge_academic_dataset',\n# which is inside the current working directory\n\ndirname <- \"yelp_dataset_challenge_academic_dataset\"\nfilestem <- \"yelp_academic_dataset_\"\nfilenamepart <- c(\"business\", \"checkin\", \"review\", \"tip\", \"user\")\nfileext <- \".json\"\nalldata <- list()\n\nfor (iter in 1:length(filenamepart)) {\n     filename = paste(dirname, \"/\", filestem, filenamepart[iter], fileext, sep = \"\")\n     dataframe = filenamepart[iter]\n     alldata[[iter]] <- fromJSON(sprintf(\"[%s]\", paste(readLines(filename), collapse = \",\")))\n     print(filename)\n     print(dataframe)\n}\n     \nnames(alldata) <- filenamepart\n\n\n#--------------------------\n# identify rows of entries pertaining to doctors or hospitals, i.e., \"mainstream\" medicine\n# including \"Health\" here does not change number of physicians or hospitals included; it\n# does increase numbers of \"Counseling & Mental Health\", \"Diagnostic Imaging\", \"Diagnostic\n# Services\", and \"Optometrists\".  It's debatable whether they should be included.\nmedrows = unique(c(grep(\"Doctor\", alldata$business$categories), \n                   grep(\"Hospital\", alldata$business$categories),\n                   grep(\"Allergist\", alldata$business$categories),\n                   grep(\"Anesthesiologist\", alldata$business$categories),\n                   grep(\"Cardiologist\", alldata$business$categories),\n                   grep(\"Surgeon\", alldata$business$categories),\n                   grep(\"Dentist\", alldata$business$categories),\n                   grep(\"Drugstore\", alldata$business$categories),\n                   grep(\"Ear Nose & Throat\", alldata$business$categories),\n                   grep(\"Endodontist\", alldata$business$categories),\n                   grep(\"Internal Medicine\", alldata$business$categories),\n                   grep(\"Laser Eye Surgery/Lasik\", alldata$business$categories),\n                   grep(\"Obstetrician\", alldata$business$categories),\n                   grep(\"Gastroenterologist\", alldata$business$categories),\n                   grep(\"Gynecologist\", alldata$business$categories),\n                   grep(\"Ophthalmologist\", alldata$business$categories),\n                   grep(\"Oncologist\", alldata$business$categories),\n                   grep(\"Orthodontist\", alldata$business$categories),\n                   grep(\"Orthopedist\", alldata$business$categories),\n                   grep(\"Orthotic\", alldata$business$categories),\n                   grep(\"Pediatric\", alldata$business$categories),\n                   grep(\"Periodontist\", alldata$business$categories),\n                   grep(\"Pharmacy\", alldata$business$categories),\n                   grep(\"Podiatrist\", alldata$business$categories),\n                   grep(\"Psychiatrist\", alldata$business$categories),\n                   grep(\"Pulmonologist\", alldata$business$categories),\n                   grep(\"Radiologist\", alldata$business$categories),\n                   grep(\"Rheumatologist\", alldata$business$categories),\n                   grep(\"Urologist\", alldata$business$categories),\n                   grep(\"Medical Center\", alldata$business$categories)))\n# length(medrows)\n# [1] 2632\n\n# remove rows of \"alternative\" medicine\nrmaltmedrows = unique(c(grep(\"Acupuncture\", alldata$business$categories[medrows]),\n                        grep(\"Massage\", alldata$business$categories[medrows]),\n                        grep(\"Naturopath\", alldata$business$categories[medrows]),\n                        grep(\"Psychic\", alldata$business$categories[medrows]),\n                        grep(\"Yoga\", alldata$business$categories[medrows]),\n                        grep(\"Spas\", alldata$business$categories[medrows]),\n                        grep(\"Food\", alldata$business$categories[medrows]),\n                        grep(\"Fitness\", alldata$business$categories[medrows]),\n                        grep(\"Osteopath\", alldata$business$categories[medrows]),\n                        grep(\"Chinese Medicine\", alldata$business$categories[medrows]),\n                        grep(\"Shopping\", alldata$business$categories[medrows]),\n                        grep(\"Chiropractor\", alldata$business$categories[medrows]),\n                        grep(\"Cannabis\", alldata$business$categories[medrows]),\n                        grep(\"Reflexology\", alldata$business$categories[medrows]),\n                        grep(\"Rolfing\", alldata$business$categories[medrows]),\n                        grep(\"Coach\", alldata$business$categories[medrows]),\n                        grep(\"Reiki\", alldata$business$categories[medrows])))\nmedrows = medrows[-rmaltmedrows]\n# length(rmaltmedrows)\n# [1] 753\n# length(medrows)\n# [1] 1879\n\n#--------------------------\n# identify rows of entries clearly pertaining to \"alternative\" medicine\n# includes only words that are clearly alternative medicine and excludes words that\n# might be compatible with both mainstream and alternative medicine (e.g., \"yoga\" \n# could be considered exercise and thus compatible with mainstream medicine).\naltmedrows = unique(c(grep(\"Acupuncture\", alldata$business$categories), \n                      grep(\"Chiropractor\", alldata$business$categories),\n                      grep(\"Chinese Medicine\", alldata$business$categories),\n                      grep(\"Reflexology\", alldata$business$categories),\n                      grep(\"Reiki\", alldata$business$categories),\n                      grep(\"Osteopath\", alldata$business$categories),\n                      grep(\"Rolfing\", alldata$business$categories),\n                      grep(\"Naturopathic\", alldata$business$categories)))\n# length(altmedrows)\n# [1] 378\n\n\n# remove rows of \"mainstream\" medicine\nrmmedrows = unique(c(grep(\"Dermatologists\", alldata$business$categories[altmedrows]),\n                     grep(\"Neurologist\", alldata$business$categories[altmedrows]),\n                     grep(\"Obstetrician\", alldata$business$categories[altmedrows]),\n                     grep(\"Gynecologist\", alldata$business$categories[altmedrows]),\n                     grep(\"Orthopedist\", alldata$business$categories[altmedrows]),\n                     grep(\"Allergist\", alldata$business$categories[altmedrows]),\n                     grep(\"Internal Medicine\", alldata$business$categories[altmedrows])))\naltmedrows = altmedrows[-rmmedrows]\n# length(rmmedrows)\n# [1] 8\n# length(altmedrows)\n# [1] 370\n\n\n\n#--------------------------\n# this section assesses what business categories are included in each group\n\n# number of clearly mainstream medicine businesses (after eliminating businesses associated with alternative medicine words)\nlength(medrows)\n# [1] 1879\n# number of reviews of clearly mainstream medicine businesses\nsum(alldata$business$review_count[medrows])\n# [1] 14250\n# business categories associated with clearly mainstream medicine businesses\ntable(unlist(alldata$business$categories[medrows]))\n# mednames = as.data.frame(table(unlist(alldata$business$categories[medrows])))[ , 1]\n\n# number of clearly alternative medicine businesses (after eliminating businesses associated with mainstream medicine words)\nlength(altmedrows)\n# [1] 370\n# number of reviews of clearly alternative medicine businesses\nsum(alldata$business$review_count[altmedrows])\n# [1] 3136\n# business categories associated with clearly alternative medicine businesses\ntable(unlist(alldata$business$categories[altmedrows]))\n\n\n#--------------------------\n# get row indices for reviews of mainstream medicine businesses\nmedrevrows = NA\nfor (iter in 1:length(medrows)) {\n     medrevrows = c(medrevrows, which(alldata$review$business_id == alldata$business$business_id[medrows[iter]]))\n}\nmedrevrows = medrevrows[-1]\n\n# get row indices for reviews of alternative medicine businesses\naltmedrevrows = NA\nfor (iter in 1:length(altmedrows)) {\n     altmedrevrows = c(altmedrevrows, which(alldata$review$business_id == alldata$business$business_id[altmedrows[iter]]))\n}\naltmedrevrows = altmedrevrows[-1]\n\nlength(medrevrows)\n# [1] 12957\nlength(altmedrevrows)\n# [1] 2883\n# matching business IDs to get reviews (here) and summing business review counts (above)\n# don't give same number of reviews:  mainstream medicine - 14250 above vs. 12957 here;\n# alternative medicine - 3136 above vs. 2883 here\n\n# create data frame of only mainstream and alternative medicine reviews\nmedrevs = alldata$review[medrevrows, c(1:4, 6, 8)]\naltmedrevs = alldata$review[altmedrevrows, c(1:4, 6, 8)]\n\nmedrevs[ , \"medicine\"] = \"conventional\"\naltmedrevs[ , \"medicine\"] = \"alternative\"\n\nrevs = rbind(medrevs, altmedrevs)\nsaveRDS(revs, file = \"revs.rds\")\n\n#--------------------------\n# now working in different R global environment (Linux instead of Windows)\n# save revs to RDS then read:\nrevs <- readRDS(\"revs.rds\")\n# re-arrange data frame of reviews\nrevs <- cbind(revs$business_id, revs[ , 2:3], revs$medicine, revs$stars, revs$votes, revs$text, stringsAsFactors = F)\ncolnames(revs) <- gsub(\"revs\\\\$\", \"\", colnames(revs))\nrevs$medicine <- as.factor(revs$medicine)\nrevs$business_id <- as.factor(revs$business_id)\nrevs <- revs[order(revs$review_id), ]\n\n\n#--------------------------\n# remove problematic reviews from data frame\nlibrary(qdap)\n\n# according to 'Encoding' and 'check_text' functions, 76 reviews are in UTF-8,\n# which can't be read by 'word_stats' function; 'iconv' couldn't convert UTF-8\n# to ASCII, so the 76 UTF-8 rows are being deleted\nutfrows <- which(Encoding(revs$text[1:15840]) == \"UTF-8\")\nrevs <- revs[-utfrows, ]\n\n# remove texts not written in English\n# create data frame with misspelling rate for each review\nmisspellnumbs <- table(check_spelling(revs$text, assume.first.correct = FALSE)$row)\nmisspells <- cbind(as.integer(rownames(misspellnumbs)), as.integer(misspellnumbs))\ncolnames(misspells) <- c(\"textrownumber\", \"misspellingsnumber\")\n# 'missingrows': not returned by check_spelling function; indicates no misspellings\nmissingrows <- setdiff(1:dim(revs)[1], misspells[ , 1])\nnomisspells <- cbind(missingrows, rep(0, length(missingrows)))   # reviews with no misspellings\nmisspells <- as.data.frame(rbind(misspells, nomisspells))        # all reviews combined  \nmisspells <- misspells[order(misspells[ , 1]), ]  \nrownames(misspells) <- 1:dim(misspells)[1]\nmisspells$totalwords <- word_count(revs$text)\nmisspells$errorrate <- misspells[ , 2] / misspells [ , 3]        # misspellings per word\n# plot(misspells[ , 4])    # shows several rows with high misspelling rate\n# identify reviews with misspelling rates > 50%\nhierrorrownumbers <- misspells[misspells[ , 4] > 0.5, 1]\nhierrorrownumbers <- hierrorrownumbers[!is.na(hierrorrownumbers)]\n# revs$text[hierrorrownumbers]\nforeigntexts <- c(1, 3)  # visual inspection shows that these reviews are not in English\n# revs$text[hierrorrownumbers[foreigntexts]]\n# revs[hierrorrownumbers[foreigntexts], ]\n# these are the row indices of the foreign-language reviews to delete from 'revs'\nnonenglish <- hierrorrownumbers[foreigntexts]\nrevs <- revs[-nonenglish, ]\n\n# row 4364:  error in 'formality' function; it says it needs a 2-D array; haven't solved\nproblemrows <- c(4364)\nrevs <- revs[-problemrows, ]\n\n\n#--------------------------\n# prepare text of reviews for analysis\n\nrevs$text = add_incomplete(revs$text)\nrevs$text = incomplete_replace(revs$text)\n\n\nsaveRDS(revs, file = \"revsculledprepped.rds\")\n\n#--------------------------\n# add analytical metrics/scores of reviews to reviews data frame\n\nrevs <- readRDS(\"revsculledprepped.rds\")\n\n# This function detects whether a sequence of a vector's elements repeats.  \n# If they do, it eliminates the duplicates/repetitions so that only one \n# sequence remains.\n\n# The sequence can extend over any number of vector elements.  There can be\n# any number of duplicates in the vector; all the duplicates will be eliminated.\n\n# The limitation of this function is that it checks for only 1 duplication.\n# If it finds 1 duplicate and the overall length of the vector is a multiple\n# of the length of the sequence, then it assumes any additional elements \n# following the first duplicate are also duplicated sequences.\n\nremoverepeats <- function(vectora) {\n     # vectors must have at least 2 elements to continue through the function\n     if (length(vectora) < 2) {return(vectora)}\n     \n     # checks whether the vector's 1st element is duplicated\n     firstrepeat <- match(vectora[1], vectora[-1], nomatch = 1)\n     # if not, function exits\n     if (firstrepeat == 1) {\n          return(vectora)\n          # if so, 'firstrepeat' is the vector index of that duplicate\n          # thus, 'firstrepeat - 1' is the length of the possible duplication sequence\n     } else if (firstrepeat > 1) {\n          firstrepeat <- firstrepeat + 1\n     }\n     \n     # vector length must be a multiple of the sequence length to continue\n     # through function\n     lengthremainder <- length(vectora) %% (firstrepeat - 1)\n     if (lengthremainder != 0) {\n          return(vectora)\n     } \n     \n     # to be a duplicate, each element of the 2nd sequence must match the \n     # corresponding element of the 1st sequence\n     repeattest = rep(FALSE, (firstrepeat - 1))\n     for (iter in 1:(firstrepeat - 1)) {\n          repeattest[iter] <- (vectora[iter] == vectora[firstrepeat + iter - 1])\n     }\n     \n     # if any element between the 2 sequences mismatched, exit function\n     if (FALSE %in% repeattest) {\n          return(vectora)\n          # otherwise, the 2nd sequence is a duplicate, and the vector is modified\n          # so that only the 1st sequence is retained\n     } else {\n          vectora <- vectora[1:(firstrepeat - 1)]\n          return(vectora)\n     }\n     \n}\n\n# 'n.imper' and 'n.incom' might be in wrong order in 'wordstatscolnames' below\n# 'p.imper' and 'p.incom' might be in wrong order in 'wordstatscolnames' below\nwordstatscolnames = c(# from word_stats function\n     \"all\", \"n.sent\", \"n.words\", \"n.char\", \"n.syl\", \"n.poly\", \n     \"wps\", \"cps\", \"sps\", \"psps\", \"cpw\", \"spw\", \"pspw\", \n     \"n.state\", \"n.quest\", \"n.exclm\", \"n.imper\", \"n.incom\", \n     \"p.state\", \"p.quest\", \"p.exclm\", \"p.imper\", \"p.incom\", \n     \"n.hapax\", \"n.dis\", \"grow.rate\", \"prop.dis\",\n     # from 'pronoun_type' function\n     \"pronoun.word.count\", \"I\", \"we\", \"you\", \"he\", \"she\", \n     \"they\", \"it\", \"me\", \"us\", \"him\", \"her\", \"them\", \"their\",\n     # from 'polarity' function\n     \"total.sentences\", \"total.words\", \"ave.polarity\",\n     \"sd.polarity\", \"stan.mean.polarity\",\n     # from 'automated_readability_index' function\n     \"read.word.count\", \"sentence.count\", \"character.count\",\n     \"Automated_Readability_Index\",\n     # from 'diversity' function\n     \"wc\", \"simpson\", \"shannon\", \"collision\", \n     \"berger_parker\", \"brillouin\",\n     # from 'lexical_classification' function\n     \"lexical.word.count\", \"ave.content.rate\", \"SE\", \"n.content\",\n     \"n.functional\", # \"content\", \"functional\",\n     # from 'formality' function\n     \"formality.word.count\", \"formality\") \n# number of columns following 'prop.dis' (last element of 'word_stats' function)\nwstatsendcol = which(wordstatscolnames == \"prop.dis\")\nafterwstatscolnum = length(wordstatscolnames) - wstatsendcol\n\ntemparray = rep(NA, length(wordstatscolnames))\ntemparray = as.data.frame(t(temparray))\ncolnames(temparray) = wordstatscolnames\n\n# starttime = proc.time()\nfor (iter in 1:dim(revs)[1]) {\n     #      print(paste(iter, \"flag1\"))\n     otherstats = rep(NA, afterwstatscolnum)         # initialize 'otherstats', which contains results from functions other than 'wordstats'\n     otherstats = as.data.frame(t(otherstats))\n     if (grepl(\"[a-zA-Z]\", revs$text[iter]) == FALSE) {          # if there is no text (i.e., no alphabetic characters) in the review\n          wordstats = rep(NA, length(wordstatscolnames))         # create 'wordstats' with 'NA's for all values\n          wordstats = as.data.frame(t(wordstats))\n          colnames(wordstats) = wordstatscolnames\n     } else {                                                    # else create 'wordstats' with 'word_stats' function calculations\n          tempsplit = sentSplit(revs[iter, ], \"text\")\n          adjrownum = length(removerepeats(tempsplit$text))\n          tempsplit = tempsplit[1:adjrownum, ]\n          otherstats[1:14] = pronoun_type(tempsplit$text)$prop[ , -1]\n          otherstats[15:19] = polarity(tempsplit$text)$group[ , -1]\n          otherstats[20:23] = automated_readability_index(tempsplit$text)$Readability[ , -1]\n          otherstats[24:29] = diversity(tempsplit$text)[ , -1]\n          # 'lexical_classification' and 'formality' produce errors if there's\n          # only one word of text in the review, so they are skipped in this case\n          if (otherstats[1] > 1) {\n               otherstats[30:34] = lexical_classification(tempsplit$text)$lexical_classification[ , 2:6]\n               dummy <- capture.output(otherstats[35:36] <- formality(tempsplit$text)$formality[ , -1])   # hacky way of preventing 'formality' from printing output\n          } else {\n               otherstats[30:36] = NA\n          }\n          wordstats = word_stats(tempsplit$text)$gts\n          \n          if (colnames(wordstats)[dim(wordstats)[2]] != wordstatscolnames[wstatsendcol]) {  \n               wordstats[dim(wordstats)[2] + 1] = NA\n               colnames(wordstats)[dim(wordstats)[2]] = wordstatscolnames[wstatsendcol]\n          }\n          # if the last column name of 'wordstats' is not \"prop.dis\" (i.e., the last element in 'wordstatscolnames'),\n          # the 'if' condition in the 'for' loop below will produce an error; the 'if' statement above avoids this\n          \n          # if a column in 'wordstats' is not present, insert column with 'NA' as value\n          for (iter2 in 1:wstatsendcol) {\n               if (colnames(wordstats)[iter2] != wordstatscolnames[iter2]) {\n                    wordstats = data.frame(wordstats[1:(iter2 - 1)], NA, wordstats[iter2:dim(wordstats)[2]])\n               }\n          }\n     }\n     wordstats[28:63] = otherstats\n     colnames(wordstats) = wordstatscolnames\n     wordstats$all = as.character(wordstats$all)  # convert 'factor' to 'character' so 'review_id' can be added (below)\n     wordstats$all = revs$review_id[iter]\n     temparray = rbind.data.frame(temparray, wordstats)\n     if (iter %% 100 == 0) {print(iter)}\n}\n# proc.time() - starttime\ntemparray = temparray[-1, ]\nrownames(temparray) = seq(from = 1, to = dim(temparray)[1])\n# table(revs$review_id == temparray$all)    # checks that rows match between 'revs' and 'temparrayall'\nrevsall = cbind(revs, temparray)\nsaveRDS(revsall, file = \"revsall.rds\")\n\n\n#--------------------------\n# add word frequencies to reviews data frame\n\nlibrary(tm)\n\nrevsall <- readRDS(\"revsall.rds\")\n\n# takes a vector of type 'character' (i.e., strings) and returns a vector of \n# numbers of the words/tokens contained within original vector\ncorpfreqprep <- function(vectoroftexts, removepunct = TRUE) {\n     corpus <- Corpus(VectorSource(vectoroftexts))\n     corpus <- tm_map(corpus, content_transformer(removeNumbers))\n     corpus <- tm_map(corpus, content_transformer(stripWhitespace))\n     if (removepunct) corpus <- tm_map(corpus, content_transformer(removePunctuation))\n     corpfreq <- colSums(as.matrix(DocumentTermMatrix(corpus)))\n     corpfreq <- sort(corpfreq, decreasing = TRUE)\n     return(corpfreq)\n}\n\n# frequencies of all words used across all reviews (not adjusted for length of reviews)\nalltextsfreq <- corpfreqprep(revsall$text, removepunct = TRUE)\n\n# remove words (mostly proper nouns) that might not generalize well to other data sets\n# 331 vegas, 393 yelp, 543 phoenix, 561 las, 660 scottsdale, 753 groupon, 1047 arizona\n# 1051 mayo, 1209 chandler, 1217 summerlin, 1331 john, 1333 nevada, 1385 miller\n# 1426 gilbert, 1317 north, 1407 west\nwordstoremove <- c(331, 393, 543, 561, 660, 753, 1047, 1051, 1209, 1217, 1317, 1331, \n                 1333, 1385, 1407, 1426)\nalltextsfreq <- alltextsfreq[-wordstoremove]\n\n# selects words that appear at least 100 times across all reviews\n# using 100 as cut-off is somewhat arbitrary\ncommonwordsnum <- match(99, alltextsfreq) - 1\ncommonwords <- names(alltextsfreq)[1:commonwordsnum]\n\n# add columns to data frame for each common word's frequency in each review\nrevsallcolnum <- dim(revsall)[2]\nrevsall[(revsallcolnum + 1):(revsallcolnum + commonwordsnum)] <- NA\ncolnames(revsall)[(revsallcolnum + 1):(revsallcolnum + commonwordsnum)] <- commonwords\n\n# for each row in 'revsall', i.e., for each review\nfor (iter in 1:dim(revsall)[1]) {\n     if (iter %% 100 == 0) {print(iter)}\n     tempfreq <- corpfreqprep(revsall$text[iter], removepunct = TRUE)\n     # if 'corpfreqprep' returns 'logical(0)' to 'tempfreq', assigning \"\" to 'tempfreq'\n     # avoid subsequent error\n     # this error occurs 8 times in the data set at these row indices in 'revsall':\n     # 1711, 1954, 6760, 8069, 8417, 8486, 9783, 10902\n     # the review texts at these row indices are:  \"Ok|\", \"|\", \".\", \"|\", \"c|\", \"A|\", \"NT|\", \":)|\"\n     # these errors do not affect the totals for the most common words, so the\n     # correction below is adequate\n     if (length(tempfreq) == 0) {\n          tempfreq <- 0\n          names(tempfreq) <- \"\"\n     }\n     # for each word counted in a review\n     for (iter2 in 1:length(tempfreq)) {\n          # if the word counted in the review is in the common words\n          if (names(tempfreq)[iter2] %in% commonwords) {\n               wordcoltemp <- which(colnames(revsall)[(revsallcolnum + 1):dim(revsall)[2]] == names(tempfreq)[iter2])\n               wordcol <- wordcoltemp + revsallcolnum\n               # save the frequency of the word as a proportion of the number of words in the review\n               revsall[iter, wordcol] <- tempfreq[iter2] / revsall$n.words[iter]\n          }\n     }\n}\n\nsaveRDS(revsall, file = \"revsallwordfreqs.rds\")\n\n#--------------------------\n# modify variables and remove unneeded variables\n\nexpdata <- readRDS(\"revsallwordfreqs.rds\")\n\n# checks word frequencies in 'expdata' against word frequencies in 'alltextsfreq'\n# to make sure data were added to 'revsall'/'expdata' correctly\n# startcol <- 73\n# stopcol <- dim(expdata)[2]\n# coltotals <- rep(NA, length(startcol:stopcol))\n# nwordscolnum <- 12\n# for (colnum in startcol:stopcol){\n#      rowwordtotal <- 0\n#      for (iter in 1:dim(expdata)[1]) {\n#           if (!is.na(expdata[iter, colnum])) {\n#                rowwordnum <- expdata[iter, colnum] * expdata[iter, nwordscolnum]\n#                rowwordtotal <- rowwordtotal + rowwordnum\n#           }\n#      }\n#      coltotals[colnum - (startcol - 1)] <- rowwordtotal\n# }\n# table(coltotals == alltextsfreq[1:commonwordsnum])     # all 1462 should be TRUE; should be no FALSEs\n\n# 'ave.polarity' is the total polarity divided by the number of sentences, but\n# the sentence number counts are unreliable.  Therefore, 'ave.polarity' will be\n# transformed to be polarity per word (instead of \"polarity per sentence\").\n# plot(abs(revsall$n.words - revsall$total.words)/mean(c(revsall$n.words, revsall$total.words), na.rm=T))\nexpdata$ave.polarity = (expdata$ave.polarity * expdata$total.sentences) / expdata$total.words\n\n# replace 'NA's with zeroes\nexpdata[is.na(expdata)] <- 0\n\n# word counts for different functions don't completely agree\n# columns of word counts:  12, 37, 52, 56, 60, 66\n# cor(revsall[,c(12, 37, 52, 56, 60, 66)], use = \"pairwise.complete.obs\")\n# correlation matrix and graphs show the agreement is very strong -- strong enough to delete extra columns\n# table(revsall$n.words == revsall$total.words)\n\n# delete: 37, 52, 56, 60, 66: columns of word counts\n# delete 9, review text\n# delete column 10, duplicate of 'review_id'\n# delete 11 'n.sent':  number of sentences is often incorrect\n# delete 16:19:  all 'per sentence' stats, which are often incorrect\n# delete 28:32:  proportions of all sentences, which are often incorrect\n# delete 33:36:  unsure how unique words would be useful; deleting\n# delete 54:55:  polarity standard deviation is by sentence count, which is often incorrect\n# delete 56:59:  readability relies on sentence counts, which are often incorrect; can I calculate something useful from this?\n# delete 63, 65:  shannon, collision, brillouin correlate very highly; keep shannon\n# delete 66, 68:70:  'ave.content.rate' (col 67) is good (expressed as %); other cols unnecessary\n# delete 71:  'formality' (col 72) is good (expressed as %); 71 is unnecessary\ncullcols = c(9:11, 16:19, 28:32, 33:37, 51:52, 54:60, 63, 65:66, 68:71)\nexpdata = expdata[ , -cullcols]\n\n\n#--------------------------\n# which word frequencies show largest difference between 'conventional' and 'alternative' medicine?\n# commonly used words with large differences might be particularly good at\n# discriminating between conventional and alternative medicine reviews\n\noptions(scipen = 999)    # avoids scientific notation when displaying results\n\nstartcol <- 40\nrelativediffs <- rep(NA, length(startcol:dim(expdata)[2]))\nrelativediffs <- cbind.data.frame(relativediffs, relativediffs)\n\n# calculate word usage rate for reviews of conventional and alternative medicine\n# rate includes all reviews for either kind of medicine, not only reviews where the word appears\nfor (varcol in startcol:dim(expdata)[2]) {\n     reldiffsrow <- varcol - (startcol - 1)\n     conmedcol <- expdata[expdata$medicine == \"conventional\", varcol]\n     altmedcol <- expdata[expdata$medicine == \"alternative\", varcol]\n     relativediffs[reldiffsrow, 1] <- mean(conmedcol)\n     relativediffs[reldiffsrow, 2] <- mean(altmedcol)\n}\n\nnwordscol <- which(colnames(expdata) == \"n.words\")\nmedicinecol <- which(colnames(expdata) == \"medicine\")\n# word frequencies for each word\nwordfreqs <- expdata[ , 40:dim(expdata)[2]] * expdata[ , nwordscol]             \n# word frequencies for each word for reviews of conventional medicine\nconmedwordfreqs <- wordfreqs[expdata[ , medicinecol] == \"conventional\", ]       \n# word frequencies for each word for reviews of alternative medicine\naltmedwordfreqs <- wordfreqs[expdata[ , medicinecol] == \"alternative\", ]        \n# ratio of number of conventional medicine to alternative medicine reviews\ncontoaltratio <- table(expdata$medicine)[[2]] / table(expdata$medicine)[[1]]    \n\n# difference in word usage rate as proportion of conventional medicine rate\nrelativediffs[ , 3] <- (abs(relativediffs[ , 1] - relativediffs[ , 2]) / relativediffs[ , 1])  \nrelativediffs[ , 4] <- colSums(wordfreqs)\nrelativediffs[ , 5] <- colSums(conmedwordfreqs)\nrelativediffs[ , 6] <- colSums(altmedwordfreqs)\nrelativediffs[ , 7] <- relativediffs[ , 5] + (relativediffs[ , 6] * contoaltratio)\n# index of how well word's usage rate may discriminate between conventional and\n# alternative medicine reviews; accounts for difference in word's usage rates\n# between conventional and alternative medicine and how frequently word is used\nrelativediffs[ , 8] <- relativediffs[ , 3] * relativediffs[ , 4]\n# same index as above, but word frequencies for alternative medicine reviews\n# have been overweighted to equal frequencies for conventional medicine review\n# this should optimize word selection for training data, which will likewise\n# overweight alternative medicine reviews\nrelativediffs[ , 9] <- relativediffs[ , 3] * relativediffs[ , 8]\nrelativediffs[ , 10] <- startcol:dim(expdata)[2]\n\ncolnames(relativediffs) <- c(\"conmedmean\", \"altmedmean\", \"reldiff\", \"totalfreq\", \"confreq\", \n                             \"altfreq\", \"totalwfreq\", \"diffxfreq\", \"diffxwfreq\", \"colindex\")\nrownames(relativediffs) <- colnames(expdata)[startcol:dim(expdata)[2]]\nrownames(relativediffs) <- gsub(\".1\", \"\", rownames(relativediffs))\n\n\n# plot relative differences to determine which words might be best discriminators\nsortreldiffs <- relativediffs[order(relativediffs[ , 3], decreasing = TRUE), ]\nsortdifffreq <- relativediffs[order(relativediffs[ , 8], decreasing = TRUE), ]\nsortdiffwfreq <- relativediffs[order(relativediffs[ , 9], decreasing = TRUE), ]\n# plot(sort(log(relativediffs[ , 3]), decreasing = TRUE))\n# abline(v = 70)\n# abline(v = 160)\n# plot(sort(log(relativediffs[ , 8]), decreasing = TRUE))\n# abline(v = 60)\n# plot(sort(log(relativediffs[ , 9]), decreasing = TRUE))\n# abline(v = 40)\n# abline(v = 80)\n\n\n#--------------------------\n# splitting data into training (60% of data) and testing (40%) sets, stratified\n# by 'medicine' ('conventional' or 'alternative') and star ratings (1 - 5)\n\nvar1 = levels(expdata$medicine)\nvar2 = sort(unique(expdata$stars))\ntestrows = NA\nset.seed(43317)\n\nfor (iter1 in 1:length(var1)) {\n     for (iter2 in 1:length(var2)) {\n          set = which(expdata$medicine == var1[iter1] & expdata$stars == var2[iter2])\n          sampledrows = sample(set, size = round(0.4 * length(set)), replace = FALSE)\n          testrows = append(testrows, sampledrows)          \n     }\n}\ntestrows = testrows[-1]\n\ntraindata = expdata[-testrows, ]\ntestdata = expdata[testrows, ]\n\n\n#--------------------------\n# oversample 'alternative' medicine stratified by star ratings to match \n# 'conventional' medicine sample size\n\nstarsbymed = cbind(as.data.frame(table(traindata[traindata$medicine == \"conventional\", ]$stars)),\n                   as.data.frame(table(traindata[traindata$medicine == \"alternative\", ]$stars)))\nstarsbymed = starsbymed[ , -c(1, 3)]\ncolnames(starsbymed) = c(\"conventional\", \"alternative\")\n\n\nvar = sort(unique(expdata$stars))\noverrows = NA\nset.seed(17830)\n\nfor (iter in 1:length(var)) {\n     set = which(traindata$medicine == \"alternative\" & traindata$stars == iter)\n     sampledrows = sample(set, size = starsbymed$conventional[iter], replace = TRUE)\n     overrows = append(overrows, sampledrows)          \n}\noverrows = overrows[-1]\n\novertraindata = rbind(traindata[traindata$medicine == \"conventional\", ], \n                      traindata[overrows, ])\n\n\n#--------------------------\n# tree model on oversampled training set\n\nlibrary(caret)\n\nwordfreqnums <- 80       # number of word frequency variables for inclusion\n# column indices for data to be included in analysis\n# columns 4 - 39 are Yelp data and the standard analyses from the package 'qdap'\n# the remaining columns are word usage rates\n# the number of words are selected inclusion are specified in 'wordfreqnums'\n# words are included based on the difference in usage rates between reviews\n# for conventional or alternative medicine multipled by word frequency that \n# has been weighted so that reviews for alternative medicine count equally as \n# those for conventional medicine\n# indices skip '1' and run from 2 to 'wordfreqnums + 1' to avoid 'reflexology',\n# which did not appear in conventional medicine reviews; since the difference\n# was divided by the word usage rate in conventional medicine reviews, the\n# difference for 'reflexology' is listed as 'infinity', which is not useful\ndiffwfreqcols <- c(4:39, sortdiffwfreq$colindex[2:wordfreqnums + 1])\n\nrpartmodelover = train(medicine ~ ., method = \"rpart\", data = overtraindata[ , diffwfreqcols])\npredrpartover = predict(rpartmodelover, testdata[ , diffwfreqcols])\n\nsink(file = \"treeoutput.txt\")\nrpartmodelover$finalModel\nconfusionMatrix(predrpartover, testdata$medicine)\nsink(file = NULL)\n\n# plot of tree for report\nlibrary(rpart.plot)\npar(mfrow = c(1, 1))\nprp(rpartmodelover$finalModel)\n",
    "created" : 1452381424847.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "213386106",
    "id" : "1326B1CD",
    "lastKnownWriteTime" : 1452380715,
    "path" : "/media/zh/My Passport/backup/2015 code share/Coursera JH 10 2015/to share/project.R",
    "project_path" : "project.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}